local M = {}

---Returns the path relative to the root directory
---@param tree editree.Tree
---@return string
function M.get_rel_path(tree)
	local parts = {}
	local node = tree
	while not node:is_root() do
		table.insert(parts, node.name)
		node = node.parent
	end
	parts = vim.iter(parts):rev():totable()
	return vim.fs.joinpath((table.unpack or unpack)(parts))
end

---Updates each node of the tree with the ID generated by the ID generator.
---@param tree editree.Tree
---@param id_generator editree.IdGenerator
M.add_ids = function(tree, id_generator)
	local i = 2
	tree:for_each(function(node)
		if not node:is_root() then
			local id = id_generator.get_id()
			node.id = id
			i = i + 1
		end
	end)
end

---@param tree editree.Tree
---@return boolean
function M.contains_unique_names(tree)
	assert(tree.type == "directory")
	local saw_name = {}
	for _, child in ipairs(tree.children) do
		if saw_name[child.name] then
			return false
		end
		saw_name[child.name] = true
	end
	return true
end

---Returns a mapping from an ID to a list of nodes with that ID.
---@param tree editree.Tree
---@param id_map table<string, editree.Tree[]>?
---@return table<string, editree.Tree[]>
function M.get_recursive_id_map(tree, id_map)
	assert(tree.type == "directory")
	id_map = id_map or vim.defaulttable(function()
		return {}
	end)
	for _, child in ipairs(tree.children) do
		if child.id then
			table.insert(id_map[child.id], child)
		end

		if child.type == "directory" then
			M.get_recursive_id_map(child, id_map)
		end
	end
	return id_map
end

---Returns a mapping from each child's ID to the child itself.
---@param tree editree.Tree
---@return table<string, editree.Tree>
function M.id_to_child_map(tree)
	assert(tree.type == "directory", "attempting to get child of non-directory")
	local map = {}
	for _, child in ipairs(tree.children) do
		map[child.id] = child
	end
	return map
end

function M.trees_are_equal(t1, t2)
  if t1.id ~= t2.id or t1.type ~= t2.type then
    return false
  end
  if t1.type == "directory" then
    if #t1.children ~= #t2.children then
      return false
    end
    for i = 1, #t1.children do
      if not M.trees_are_equal(t1.children[i], t2.children[i]) then
        return false
      end
    end
  end
  return true
end

return M
